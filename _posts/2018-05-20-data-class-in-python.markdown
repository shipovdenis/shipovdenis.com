---
layout: post
title:  "Классы данных в Python"
description: "Основы классов данных с применением декоратора @dataclass. Существующие
альтернативы классам данных."
permalink: /blog/python-dataclass
---

Одной из интересных особенностей, появившихся в __Python__ с версии __3.7__, является __класс данных__(__data class__). __Класс данных__ — это класс, как правило содержащий только данные, но в действительности нет никаких ограничений. Он создается с помощью нового декоратора __@dataclass__

```python
from dataclasses import dataclass

@dataclass
class DataClassCard:
    rank: str
    suit: str
```

> Все примеры в этой статье будут корректно работать только в __Python 3.7__ и выше.

__Классы данных__ уже обладают реализованной базовой функциональностью, например, вы можете создавать экземпляры, печатать, сравнивать их между собой, не прилагая для этого никаких усилий:

```python
>>> queen_of_hearts = DataClassCard('Q', 'Hearts')
>>> queen_of_hearts.rank
'Q'
>>> queen_of_hearts
DataClassCard(rank='Q', suit='Hearts')
>>> queen_of_hearts == DataClassCard('Q', 'Hearts')
True
```

Сравним с обычными классами. Минимальная реализация выглядит следующим образом:

```python
class RegularCard
    def __init__(self, rank, suit):
        self.rank = rank
        self.suit = suit
```

В таком простом примере разница в количестве написанного кода незначительная, однако сразу видны потенциальные проблемы: переменные __rank__ и __suit__ повторяются по три раза только для инициализации экземпляров объекта. Более того, если попытаться использовать этот класс, то представление объекта не особо информативно и почему-то один экземпляр __queen_of_hearts__ не равен другому:

```python
>>> queen_of_hearts = RegularCard('Q', 'Hearts')
>>> queen_of_hearts.rank
'Q'
>>> queen_of_hearts
<__main__.RegularCard object at 0x7fb6eee35d30>
>>> queen_of_hearts == RegularCard('Q', 'Hearts')
False
```

Понятно, что декоратор __@dataclass__ выполняет определенные действия "за кулисами".
__Класс данных__ уже реализует метод __\_\_repr\_\_()__ для обеспечения хорошего строкого представления и метод __\_\_eq\_\_()__, который выполняет базовые сравнения объектов. Чтобы класс __RegularCard__ обладал схожей функциональностью, нужно добавить это методы явно:

```python
class RegularCard
    def __init__(self, rank, suit):
        self.rank = rank
        self.suit = suit

    def __repr__(self):
        return (f'{self.__class__.__name__}'
                f'(rank={self.rank!r}, suit={self.suit!r})')

    def __eq__(self, other):
        if other.__class__ is not self.__class__:
            return NotImplemented
        return (self.rank, self.suit) == (other.rank, other.suit)
```

Эта статья показывает какие преимущества дают __классы данных__, помимо описанных выше. Мы рассмотрим:

* Как устанавливать значения по умолчанию для полей объекта?
* Как упорядочивать множество объектов?
* Как представлять неизменяемые данные?
* Как работает наследование в __классах данных__?

Скоро мы погрузимся в эти особенности новой функциональности __Python__. Однако, вам может показаться, что вы уже видели что-то подобное раньше.

# Существующие альтернативы классам данных

Для простых структур данных вы, вероятно, уже использовали кортежи или словари:

```python
>>> queen_of_hearts_tuple = ('Q', 'Hearts')
>>> queen_of_hearts_dict = {'rank': 'Q', 'suit': 'Hearts'}
```

Это работает, но накладывает большую ответственность на программиста:

* Нужно помнить, структуру какой сущности представляют __queen_of_hearts_tuple__ и __queen_of_hearts_dict__.

* Для __queen_of_hearts_tuple__ нужно помнить порядок следования атрибутов. 
Написав __queen_of_hearts_tuple = ('Hearts', 'Q')__ мы явно получим не то, что хотели, однако сообщение об ошибке не возникнет.

* При использовании словарей нужно следить за согласованностью имен атрибутов. Например, __queen_of_hearts_dict = {'value': 'A', 'suit': 'Spades'}__ не будет работать должным образом, так как впоследствии мы ожидаем поле __rank__, а не __value__.

Более того, использование таких структур далеко от идеала с точки зрения чистоты и информативности кода:

```python
>>> queen_of_hearts_tuple[0]  # Доступ по индексу, а не имени
'Q'
>>> queen_of_hearts_dict['suit']  # Хотелось бы .suit
'Hearts'
```

Лучшей альтернативой является использование __именованных кортежей__(__namedtuple__). Этот подход широко используется для создания небольших читаемых структур данных. Класс выше с использованием __namedtuple__ создается следующим образом:

```python
from collections import namedtuple

NamedTupleCard = namedtuple('NamedTupleCard', ['rank', 'suit'])
```

Такое определение __NamedTupleCard__ дает такой же результат как и класс __DataClassCard__:

```python
>>> queen_of_hearts = NamedTupleCard('Q', 'Hearts')
>>> queen_of_hearts.rank
'Q'
>>> queen_of_hearts
NamedTupleCard(rank='Q', suit='Hearts')
>>> queen_of_hearts == NamedTupleCard('Q', 'Hearts')
True
```

Так зачем тогда вообще возиться с классами данных? Во первых, классы данных имеют более широкие возможности, чем были продемонстрированы на данный момент. В тоже время __namedtuple__ обладает и другими особенностями, которые не всегда желательны. По своей структуре __namedtuple__ является обычным кортежом. Это можно увидеть в сравнении:

```python
>>> queen_of_hearts == ('Q', 'Hearts')
True
```

На первый взгляд выглядит хорошо, однако недостаточная осведомленность о собственном типе может привести с неприятным ошибкам, которые нелегко отследить. Более того, будут легко проведено сравнение между разными именованными кортежами:

```python
>>> Person = namedtuple('Person', ['first_initial', 'last_name']
>>> ace_of_spades = NamedTupleCard('A', 'Spades')
>>> ace_of_spades == Person('A', 'Spades')
True
```

В именнованных кортежах сложно определять значения по-умолчанию, и по своей природе они являются неизменяемыми структурами данных, что в одних случаях просто превосходно, но в других сказывается недостаток гибкости:

```python
>>> card = NamedTupleCard('7', 'Diamonds')
>>> card.rank = '9'
AttributeError: can't set attribute
```

Классы данных полностью не заменяют все способы применения именованных кортежей. Если нужна структура данных, которая должна вести себя как кортеж, то нет никаких причин не использовать __namedtuple__.

Другой альтернативой и одним из вдохновителей для классов данных является библиотека __attrs__. Ее можно установить с помощью __pip__

```bash
pip install attrs
```

и реализовать наш класс следующим образом:

```python
import attr

@attr.s
class AttrsCard:
    rank = attr.ib()
    suit = attr.ib()
```

Библиотека __attrs__ содержит функциональность, которой не обладают классы данных, например, валидаторы и конвертеры. Более того, __attrs__ поддерживает Python 2.7 и Python 3.4 и выше. Но все-таки это не часть стандартной библиотеки и придется добавлять лишнюю зависимость в проект.

Помимо обычных и именованных кортежей, словарей и __attrs__ существует множество других средств, предоставляющих схожую функциональность, например, __typing.NamedTuple__, __namedlist__, __attrdict__, __plumber__, __fields__. И нужно смотреть в каждом конкретном случае, какой из них подойдет лучше всего для стоящей задачи.

# Основы классов данных